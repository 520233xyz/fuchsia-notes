\section{lkmain}
\begin{verbatim}
thread_init_early()
  thread_construct_first(t, "bootstrap");
    在主cpu上创建一个反映当前运行状态的thread_t
    拿到的cpu num是0
    thread_t清零
    THREAD_MAGIC暂时不知道什么用
    设置thread名字
    retcode_wait_queue的前驱后继都指向自己
    从tpidr_el1中拿到boot_cpu_fake_thread_pointer_location的地址

    __has_feature(safe_stack)是clang的特性，对gcc来说，
        unsafe_sp就是0（在start.S里安排的）
    把x18保存在current_percpu_ptr里
    让tpidr_el1指向这个真正的thread_t，也就是percpu里的
    idle_thread
    把这个thread加到全局的thread list上

sched_init_early()初始化各个cpu的run queue为空。

调用C++的全局变量的构造函数__init_array_start。

lk_init_level()
  required_flag = LK_INIT_FLAG_PRIMARY_CPU
  start_level = LK_INIT_LEVEL_EARLIEST
  stop_level = LK_INIT_LEVEL_ARCH_EARLY - 1
  这次没有匹配的init函数可以被调用。（也许我漏掉了？）

arch_early_init();
  x86_mmu_early_init();
    x86_mmu_percpu_init();

  arch_curr_cpu_num_slow()返回0，因为这时arm64_cpu_map还没有初始化。
  arch.cpp: arm64_cpu_early_init()
  把x18指向当前cpu的percpu.
  让VBAR_EL1指向exceptions.S中的arm64_el1_exception_base.
  把一些cpu feature读到arm64_features里
  打开DAIF遮掩位。

lk_primary_cpu_init_level(LK_INIT_LEVEL_ARCH_EARLY, LK_INIT_LEVEL_PLATFORM_EARLY - 1);

platform_early_init()
x64:
  pc_init_debug_default_early();
  platform_save_bootloader_data();
  pc_init_debug_early();
    handle_serial_cmdline()
      bootloader.uart.type = ZBI_UART_PC_PORT;
      bootloader.uart.base = 0x3f8;
      bootloader.uart.irq = ISA_IRQ_SERIAL1;
    uart_io_port = static_cast<uint32_t>(bootloader.uart.base);
    uart_irq = bootloader.uart.irq;
  platform_early_display_init();
  boot_reserve_init();
    boot_reserve_add_range(get_kernel_base_phys(), get_kernel_size());
  platform_preserve_ramdisk();

  pc_mem_init();
    platform_mem_range_init()
    efi_range_init(&range, &efi_seq)
    e820_range_init(&range, &e820_seq)
    multiboot_range_init(&range, &multiboot_seq)

  boot_reserve_wire();
    pmm_alloc_range(res[i].pa, pages, &reserved_page_list);
      // walk through the arenas, looking to see if the physical page belongs to it
      把之前保留的物理页标记成wired

lk_primary_cpu_init_level(LK_INIT_LEVEL_PLATFORM_EARLY, LK_INIT_LEVEL_TARGET_EARLY - 1);
  counters_init()

target_early_init();
  // empty

lk_primary_cpu_init_level(LK_INIT_LEVEL_TARGET_EARLY, LK_INIT_LEVEL_VM_PREHEAP - 1);
  crypto::GlobalPRNG::EarlyBootSeed

vm_init_preheap();
  VmAspace::KernelAspaceInitPreHeap();
















bootdata_paddr存放的是initrd的加载地址0x48000000。boot-shim会把从device tree
中读出来的initrd的加载地址写入bootdata_paddr。此外，qemu会把内核加载到0x40080000处。
内核的实际物理地址就是0x40090000。这些细节需要从qemu的源码中获得。

boot_reserve_add_range(get_kernel_base_phys(), get_kernel_size())
把kernel占用的物理地址区域保留起来，也就是0x40090000开始的一块区域。

接下来会处理append_board_bootdata()里加入的一些bootdata的section.

然后到pdev_init()里调用各个周边设备驱动的初始化代码。

把ramdisk所在的0x48000000开始的一块内存保留起来。

kernel.memory-limit-mb这个命令行参数应该是没有设置的。

在每个物理内存mem arena的尾部放置的是一堆描述page的vm_page_t。

把之前标记为保留的内存区域在arena中保留出来，标记成WIRED。

platform_early_init()结束。

终于来到了"welcome to Zircon"。

接下来调用crypto::GlobalPRNG::EarlyBootSeed()，初始化一些随机数生成器相关的东西。

进入vm_init_preheap()，初始化一个唯一的内核虚拟地址空间。

把boot time allocator用掉的内存（主要是分配给translation table）在物理内存管理pmm里标记为已用。

随机保留分配一些页面。可能是为了增加内存随机性。

用dc zva把缓存置零。

进入heap_init()，把内核要使用的heap page申请出来。

进入vm_init()。为内核占用的虚拟地址区域创建VmObject. VmMapping好像只是记录一个vmo有哪些flags. 在创建VmMapping之后，
Activate()的时候才把它插到parent，也就是RootVmar的ChildList里面。

platform_init_postvm()把外围设备的虚拟地址保留起来。

kernel_init(), 初始化多处理器的一些状态。初始化每个处理器的timer. 之后，内核就可以创建线程了。缺省的线程stack大小是8k.

线程执行轨迹的切换通过改变x30完成。x30是link register，
存储的是arm64_context_switch()函数调用语句的下一条指令的地址。
当在arm64_context_switch()里面切换了sp之后，新的x30从新线程的栈上pop出来。
ret指令接着x30存储的地址继续执行。实际上，每个线程的x30存储的地址都是一样的，因为
arm64_context_switch()只在一个地方被调用。

bootstrap2.

初始化deferred procedure call (dpc)线程。

初始化Handle和Arena. 这个过程没有page committed。内存页真正分配出去是在做Arena::Pool::Pop()的时候。
在VmMappingCoalescer::Flush()里会建立物理页表的映射。在做VmMapping的时候，如果不指定起始地址，
则会去找一个gap地址。

PortDispatcher暂时不知道干啥的。

进入arch_init()

给每个cpu创建一个idle thread.  释放副cpu的spin lock.

进入platform_init(). 给每个副cpu创建kernel stack, 是一个VmMapping.

pdev_run_hooks()

moving to last init leve.

user level init: ktrace, console, userboot.

ktrace: 给它分配一块内存，缺省为32MB

kernel console通过uart读命令。

\end{verbatim}













