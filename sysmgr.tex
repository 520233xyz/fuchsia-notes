\section{sysmgr}

\begin{verbatim}

main.cc: main()
================

auto command_line = fxl::CommandLineFromArgcArgv(argc, argv);
    CommandLineFromIterators(argv, argv + argc); char **
        CommandLineFromIteratorsFindFirstPositionalArg<InputIterator>(first, last, nullptr);

fxl::SetLogSettingsFromCommandLine(command_line)
    ParseLogSettings(command_line, &settings)

async::Loop loop(&kAsyncLoopConfigMakeDefault);
    Loop::Loop(const async_loop_config_t* config)
        async_loop_create(config, &loop_);
            async_loop_t* loop = calloc(1u, sizeof(async_loop_t));
            初始化一些变量
            zx_port_create(0u, &loop->port);
                PortDispatcher::Create(options, &dispatcher, &rights);
                    PortDispatcher(options);
            zx_timer_create(0u, ZX_CLOCK_MONOTONIC, &loop->timer);     
            zx_object_wait_async(loop->timer, loop->port, KEY_CONTROL,
                                      ZX_TIMER_SIGNALED,
                                      ZX_WAIT_ASYNC_REPEATING);
            让port等待timer
            async_set_default(&loop->async);
                g_default = async;



sysmgr::App app;
RegisterSingleton()注册一个callback给目录服务，当有请求过来时，
要做的事情是把发过来的请求channel handle交给相应的服务。具体如下。
fuchsia::sys::Services services;
dup_launch_info.directory_request = services.NewRequest();
    这里生成一个通道。一端给Services留作directory_, 另一端发给服务进程。
    这样就建立了Services到服务进程的通道。
it->second.ConnectToService(std::move(client_handle), service_name);
    这里会把请求通道handle通过Services的directory_发送给服务进程。


zx::channel CreateStaticServiceRootHandle() {
  zx::channel h1, h2;
  if (zx::channel::create(0, &h1, &h2) != ZX_OK) return zx::channel();
  // TODO(abarth): Use kServiceRootPath once that actually works.
  if (fdio_service_connect("/svc/.", h1.release()) != ZX_OK)
    return zx::channel();
  return h2;
}

当访问一个服务路径的时候，会创建相应的服务，然后连接这个服务
it->second.ConnectToService(std::move(client_handle), service_name)
    it->second的类型是component::Services
    component::ConnectToService(directory_, std::move(request), service_path)
        fdio_service_connect_at(directory.get(), service_path.c_str(),equest.release());
            zxrio_connect(dir, h, ZXRIO_OPEN, ZX_FS_RIGHT_READABLE |
                            ZX_FS_RIGHT_WRITABLE, 0755, path);
                zx_channel_write(svc, 0, &msg, ZXRIO_HDR_SZ + msg.datalen, msg.handle, 1)

"apps": [ "netcfg" ]
"apps": [ "thermd" ]
"apps": [ "wlancfg" ]
"apps": [
    "device_runner"
  ]
  "apps": [
    [ "set_root_view", "dashboard" ]
  ]
  "apps": [
    [ "set_root_view", "term" ]
  ]
  "apps": [
    [ "set_root_view", "ermine_user_shell" ]
  ]
"startup_services": [
    "fuchsia.amber.Control"
]

先看一下sysmgr是如何与appmgr里的fuchsia::sys::Launcher建立通道的。
sysmgr:
env_->GetLauncher(env_launcher_.NewRequest());

appmgr:

env_launcher_.NewRequest()
  zx::channel::create(0, &h1, &h2)

  return InterfaceRequest<Interface>(std::move(h2));

Namespace::GetLauncher(fidl::InterfaceRequest<Launcher> launcher)


sysmgr启动app通过fuchsia::sys::Launcher::CreateComponent().  
调用的是appmgr里的Namespace::CreateComponent()

sysmgr:
env_launcher_->CreateComponent(std::move(launch_info), nullptr);

appmgr:
realm_->CreateComponent(std::move(launch_info), std::move(controller));

\end{verbatim}
